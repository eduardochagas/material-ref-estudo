######################################################################
#
#	Módulo Pygame
#
######################################################################

=========================================================================
 Algumas anotações importantes sobre o pygame para "dar um norte" 
 sobre o funcionamento de alguns métodos 
=========================================================================

    o método pygame.display.set_mode((width, height)) É UMA SURFACE, isso significa que podemos utilizar qualquer método da classe Surface LOGO APÓS O MÉTODO set_mode() NESSE MESMO COMANDO, mas como vamos somente criar a janela do jogo, NÃO SERÁ NECESSÁRIO utilizar MÉTODOS DA CLASSE Surface. 
	    

    ao carregar a imagem com o pygame.image.load('imagem.extensão'), a imagem se torna uma SURFACE, isso significa que a imagem passa a trabalhar com todos os métodos da classe Surface do pygame.

	ex:
	    img = pygame.image.load('imagem.extensão') # defina essa linha FORA DO LOOP.

	    OBS: é importante que ao carregar uma imagem para o Pygame, utilizar o método convert(), assim a imagem será convertida no Pygame de uma forma que o Pygame possa manipula-la de uma forma mais fácil no jogo.


	    screen.blit(img, (posX, posY)) # (LEMBRA QUE A TELA DO JOGO TBM É UMA SURFACE?) defina essa linha DENTRO DO LOOP do jogo.
	    



=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

    para importar o módulo pygame

	import pygame


    para iniciar o módulo pygame

        pygame.init() - inicia todos os módulo do pygame.
	OBS: caso precise somente de um submódulo específico do pygame (contanto que esse submódulo contenha o método init()), vc pode chamar somente o submódulo especifico (por exemplo: pygame.sound.init()) individualmente, sem usar o pygame.init() (que chama todos os submódulos do pygame), isso faz com que o script seja executado mais rápido pq somente os módulos que serão realmente usados serão inicializados.


    OBS: caso não consiga fechar a janela do pygame, utilize: Ctrl + C


--------------------------------------------------------------------

modulo pygame

    pygame.init() - inicia todos os módulo do pygame.
	
	OBS: SE VC OBSERVAR, pygame.init() RETORNA UMA TUPLA IGUAL A (6,0). O pygame.init() RETORNA UMA TUPLA QUE CONTÊM O NÚMERO DE INICIALIZAÇÕES BEM-SUCEDIDAS, SEGUIDO DO NÚMERO DE INICIALIZAÇÕES COM FALHA.


    pygame.quit() - finaliza/encerra o uso de todos os módulos do pygame.



--------------------------------------------------------------------

modulo mouse do pygame

    pygame.mouse.get_pos() - esse método é uma tupla que contêm o valor (x,y) da posição do mouse.

	// exemplo de como definir uma superficie á posição do mouse 
	    imagem = pygame.image.load(imagem.png) (ao ser carregada a imagem, a imagem SE TORNA UMA SURFACE)

	    x,y = pygame.mouse.get_pos()
            x -= imagem.get_width() / 2
            y -= imagem.get_height() / 2

    	    screen.blit(imagem, (x,y))


    pygame.mouse.get_pressed() - retorna uma sequencia de boleanos representando o estado de todos os três botoes do mouse. Um valor True significa que o mouse está atualmente sendo pressionado na hora da chamada do evento (na hora em que o botão é clicado).
    OBS: lembre-se de chamar pygame.event.get() antes dessa função.



---------------------------------------------------------------------

modulo surface do pygame

    pygame.Surface((x, y)) - usado para criar uma surface.

	OBS: É RECOMENDADO UTILIZAR UM OBJETO SURFACE INICIALMENTE NA CONSTRUÇÃO DO PROJETO NO LUGAR DAS IMAGENS EM UM PROJETO, SOMENTE PARA SER MAIS RÁPIDO O DESENVOLVIMENTO DO PROJETO. DEPOIS VC PODE TROCAR OS OBJETOS SURFACE COLOCANDO AS IMAGENS NO LUGAR DESSES OBJETOS SURFACE (PQ AS IMAGENS TBM SÃO DO TIPO SURFACE).


    pygame.Surface.blit(surface, (x,y)) - é usado para copiar uma superfície para inserir em outra superfície. Muito usado para desenhar backgrounds, fontes, personagens e praticamente tudo o mais em um jogo!. Para fazer o blit de uma superfície, chame blit() a partir do objeto de superfície destino (GERALMENTE O DISPLAY) e forneça-lhe a superfície de origem (SEU SPRITE, BACKGROUND, E ASSIM POR DIANTE), seguido da coordenada com a posição (x, y) que vc deseja fazer o blit. A instrução abaixo faz o blit() de uma superfície chamada background no canto superior esquerdo da tela. Se background tiver as mesmas dimensões de screen, não será necessário preencher a tela com uma cor sólida usando o método screen.fill((0, 0, 0)).

	ex:
	    screen.blit(background, (0, 0))	

	
	Também podemos fazer o blit() DE APENAS UMA PARTE DA SUPERFÍCIE AO ADICIONAR UM OBJETO DO TIPO Rect AO PARÃMETRO QUE DEFINE A REGIÃO DE ORIGEM.

	    ex:
		screen.blit(personagem, (posX, posY), Rect(x, y, width, height)) # o Rect é inserido como o terceiro parâmetro (opcional) do blit().
		 


    pygame.Surface.convert() - converte a imagem para o mesmo formato do display da tela do jogo.
        OBS: Se vc não usar o método .convert() em suas superficies no Pygame, o código funcionará independendemente dos tipos de imagens usados no jogo (LEMBRANDO QUE IMAGENS TBM SÃO SUPERFÍCIES).

        ex:
	    img = pygame.image.load('figura1.png').convert()


        A única desvantagem dessa conversão automática é que o Pygame terá mais trabalho a fazer se você estiver usando imagens com formatos diferentes, e isso poderá, possivelmente, reduzir o desempenho do jogo. A solução é será converter todas as suas imagens para o mesmo formato. Os objetos de superfície têm um método .convert() para isso.
 

    pygame.Surface.convert_alpha() - 

    pygame.Surface.get_width() - pega a largura da superficie (que é um número).

    pygame.Surface.get_height() - pega a altura da superficie (que é um número).

    pygame.surface.fill(cor, rect) - usado para preencher uma superficie com uma cor (normalmente no formato RGB). O método pygame.Surface.fill() ACEITA UM RETÂNGULO OPCIONAL que define a área a ser limpa (ou seja, limpa (cobre de preto) somente a área do retângulo definida no parâmetro).

	ex:
	    pygame.init()
	    screen = pygame.display.set_mode((640, 480), 0, 32)


	    while True:
                for event in pygame.event.get():
                    if event.type == pygame.QUIT:
                        pygame.quit()
            		exit()

    	        screen.fill((255, 0, 0), pygame.Rect(50, 0, 100, 100))
      		
		pygame.display.update()


        OBS: SE VC DESENHAR SOBRE TODA A TELA COM OUTROS MODOS, NÃO SERÁ NECESSÁRIO LIMPÁ-LA COM UMA CHAMADA A fill().



    pygame.Surface.set_clip((x, y, largura, altura)) - usado para criar uma área em uma superfície (como por exemplo, a tela do jogo) para definir a parte de uma tela em que podemos desenhar objetos. 

        ex:
	    import pygame
	    from pygame.locals import *
	    from sys import exit


	    # colors
	    red = (255, 0, 0)
	    green = (0, 255, 0)
	    blue = (0, 0, 255)
	    orange = (255, 127, 0)

	    r = pygame.Surface((50, 50))
	    r.fill((0,255,0))

	    # initializes Pygame
	    pygame.init()

	    # sets the window title
	    pygame.display.set_caption(u'Clipping')

	    # sets the window size
	    screen = pygame.display.set_mode((400, 400))

	    # infinite loop
	    while True:

	        for event in pygame.event.get():

	            # if the 'close' button of the window is pressed
	            if event.type == pygame.QUIT:
	                # stops the application
	                break

	        # sets the clipping region at x=0, y=0, width=200, height=200
	        screen.set_clip(0, 0, 200, 200)

	        # sets the background color of the active clipping region
	        screen.fill(red)

	        # desenhando um retângulo para mostrar até em que lugar da tela o metodo set_clip() deixa desenhar... 
	        # repare que o quadrado verde desenhado na área clippada está com 10 pixels para fora da área clippada, ou seja, por causa da área 			# clippada, não conseguimos ver os 10 pixels do nosso quadrado.
	        screen.blit(r, (160, 150))

	        pygame.display.update()  


    pygame.Surface.get_clip() - usado para pegar uma área criada com o método pygame.Surface.set_clip().

    pygame.Surface.subsurface(x, y, largura, altura) - esse método aceita um retângulo que define a parte da superficie-Pai que ele deve cobrir. Um novo objeto surface será retornado, com o mesmo formato de cor da superficie-Pai.

	ex:
	    import pygame
	    from pygame.locals import *
	    from sys import exit


	    RED = (255, 0, 0)
	    GREEN = (0, 255, 0)

	    pygame.init()
	    screen = pygame.display.set_mode((500, 500))

	    array_letras = []

	    surf = pygame.image.load('font.png')
	    for i in range(1, 6):
	        subsurf = surf.subsurface(i*33, 35, 30, 30) # pega uma área retângular da superficíe-Pai
	        array_letras.append(subsurf)


	    while True:
	        for event in pygame.event.get():
	            if event.type == pygame.QUIT:
	                pygame.quit()
	                exit()

	        screen.fill((0,0,0))

	        # exibe na tela do Pygame a superficie utilizada.
	        screen.blit(surf, (0,0))

	        # exibe na tela do Pygame 
	        screen.blit(array_letras[0], (10, 200)) # somente exibindo na tela do pygame para mostrar a superficie "o que foi recortado" da superficie-Pai
	        screen.blit(array_letras[1], (50, 200)) # somente exibindo na tela do pygame para mostrar a superficie "o que foi recortado" da superficie-Pai
	        screen.blit(array_letras[2], (85, 200)) # somente exibindo na tela do pygame para mostrar a superficie "o que foi recortado" da superficie-Pai
	        screen.blit(array_letras[3], (130, 200)) # somente exibindo na tela do pygame para mostrar a superficie "o que foi recortado" da superficie-Pai
	        screen.blit(array_letras[4], (170, 200)) # somente exibindo na tela do pygame para mostrar a superficie "o que foi recortado" da superficie-Pai


	        pygame.display.update()

        
	OBS: AO TRABALHAR COM SUBSUPERFICIES, É IMPORTANTE LEMBRAR-SE DE QUE ELAS TÊM SEU PRÓPRIO SISTEMA DE COORDENADAS. EM OUTRAS PALAVRAS, O PONTO (0, 0) (que é o ponto (x,y) das coordenadas) DE UMA SUBSUPERFÍCIE SERÁ SEMPRE O CANTO SUPERIOR ESQUERDO, INDEPENDENTEMENTE DO LOCAL EM QUE ELA ESTIVER EM SUA SUBSUPERFÍCIE.


    pygame.Surface.set_at((x,y), color) - desenha um unico pixel em uma superfície. Esse método aceita a coordenada do pixel que vc deseja definir, seguido da cor que vc quer atribuir a esse pixel.

	ex:
	    import pygame
	    from pygame.locals import *
	    from sys import exit
	    from random import randint

	    pygame.init()
	    screen = pygame.display.set_mode((640, 480), 0, 32)

	    while True:
	        for event in pygame.event.get():
	            if event.type == pygame.QUIT:
	                pygame.quit()
	                exit()

	        rand_col = (randint(0, 255), randint(0, 255), randint(0, 255))
	        for _ in range(100):
	            rand_pos = (randint(0, 639), randint(0, 479))
	            screen.set_at(rand_pos, rand_col)

	        pygame.display.update()


    pygame.Surface.get_at((x,y)) - retorna a cor do pixel na coordenada (x,y) especificada.

	OBS: OBTER PIXELS SERÁ OCASIONALMENTE NECESSÁRIO PARA DETECÇÃO DE COLISÃO PARA QUE O CÓDIGO POSSA DETERMINAR ONDE ESTÁ O PERSONAGEM DO JOGADOR AO OBSERVAR A COR EMBAIXO DELE. SE TODAS AS PLATAFORMAS E OBSTÁCULOS FOREM DE DETERMINADA COR (OU DE UM DETERMINADO CONJUNTO DE CORES), ISSO FUNCIONARÁ MUITO BEM. get_at() ACEITA APENAS UM PARÂMETRO, QUE DEVE SER UMA TUPLA DE COORDENADAS DO PIXEL QUE VC QUER OBTER.

	OBS2: O MÉTODO get_at() PODE SER BEM LENTO QUANDO ESTIVER LENDE DE SUPERFICIES DE HARDWARE. O DISPLAY PODE SER UMA SUPERFÍCIE DE HARDWARE, ESPECIALMENTE SE VOCÊ ESTIVER EXECUTANDO EM MODO DE TELA CHEIA - PORTANTO, VOCÊ DEVERÁ EVITAR OBTER PIXEL DO DISPLAY.

	    
    pygame.Surface.lock() - usado para BLOQUEAR UMA SUPERFÍCIE MANUALMENTE para que se possa desenhar nessa superfície bloqueada.

	ex:
	    import pygame
	    from pygame.locals import *
	    from sys import exit
	    from random import randint

	    pygame.init()
	    screen = pygame.display.set_mode((640, 480), 0, 32)

	    while True:
	        for event in pygame.event.get():
	            if event.type == pygame.QUIT:
	                pygame.quit()
	                exit()

		screen.lock() #tranca a tela para que os objetos sejam desenhados...

	        rand_col = (randint(0, 255), randint(0, 255), randint(0, 255))
	        for _ in range(100):
	            rand_pos = (randint(0, 639), randint(0, 479))
	            screen.set_at(rand_pos, rand_col)

		screen.unlock() #desbloqueia a tela depois de todos os objetos serem desenhados...

	        pygame.display.update()    

	OBS: O BLOQUEIO E O DESBLOQUEIO OCORRERÃO AUTOMATICAMENTE SEMPRE QUE VC DESENHAR SOBRE UMA SUPERFÍCIE, PORÉM ISSO PODERÁ SE TORNAR INEFICIENTE SE O PYGAME TIVER DE REALIZAR MUITOS BLOQUEIOS E DESBLOQUEIOS. PODEMOS REDUZIR O NÚMERO DE BLOQUEIOS E DE DESBLOQUEIOS E AGILIZAR O LOOP AO FAZER O BLOQUEIO MANUALMENTE COMO MOSTRA NO EXEMPLO ACIMA, QUE EXECUTA O CÓDIGO MAIS RÁPIDO, POIS HÁ UMA CHAMADA A lock ANTES DE DESENHAR E UMA CHAMADA A unlock DEPOIS QUE TODOS OS PIXELS FOREM DESENHADOS.

	OBS2: NEM TODAS AS SUPERFÍCIES PRECISAM SER BLOQUEADAS. AS SUPERFÍCIES DE HARDWARE PRECISAM SER (A TELA É GERALMENTE UMA SUPERFÍCIE DE HARDWARE), MAS AS SUPERFÍCIES DE SOFTWARE NÃO PRECISAM DE SER BLOQUEADAS.

	OBS3: DEVE HAVER O MESMO NÚMERO DE CHAMADAS TANTO PARA BLOQUEAR QUANTO CHAMADAS PARA DESBLOQUEAR. SE VC ESQUECER-SE DE DESBLOQUEAR UMA SUPERFÍCIE, O PYGAME PODERÁ DEIXAR DE RESPONDER.



    pygame.Surface.unlock() - usado para desbloquear a superfície depois que a superfície foi aberta com pygame.Surface.lock() e os objetos foram desenhados na tela.

	OBS: O BLOQUEIO E O DESBLOQUEIO OCORRERÃO AUTOMATICAMENTE SEMPRE QUE VC DESENHAR SOBRE UMA SUPERFÍCIE, PORÉM ISSO PODERÁ SE TORNAR INEFICIENTE SE O PYGAME TIVER DE REALIZAR MUITOS BLOQUEIOS E DESBLOQUEIOS. PODEMOS REDUZIR O NÚMERO DE BLOQUEIOS E DE DESBLOQUEIOS E AGILIZAR O LOOP AO FAZER O BLOQUEIO MANUALMENTE COMO MOSTRA NO EXEMPLO ACIMA, QUE EXECUTA O CÓDIGO MAIS RÁPIDO, POIS HÁ UMA CHAMADA A lock ANTES DE DESENHAR E UMA CHAMADA A unlock DEPOIS QUE TODOS OS PIXELS FOREM DESENHADOS.

	OBS2: DEVE HAVER O MESMO NÚMERO DE CHAMADAS TANTO PARA BLOQUEAR QUANTO CHAMADAS PARA DESBLOQUEAR. SE VC ESQUECER-SE DE DESBLOQUEAR UMA SUPERFÍCIE, O PYGAME PODERÁ DEIXAR DE RESPONDER. 



---------------------------------------------------------------------
 
modulo display do pygame

    pygame.display.set_mode((width, height), flag) - a chamada desse método em seu script, RETORNA UM OBJETO SURFACE que representa a janela em seu desktop e cria a tela do jogo na largura e altura definido na tupla. O parâmetro flag é opcional, É UM RECURSO que PODE SER ATIVADO ou DESATIVADO. Várias flags podem ser combinadas com o operador bitwise OR ou o operador bit a bit (|), por exemplo, para criar uma superficie de hardware com buffer duplo (double-buffered), defina o parâmetro flags com: DOUBLEBUF | HWSURFACE, assim:

	ex:
	    pygame.display.set_mode((width, height), DOUBLEBUF | HWSURFACE, depth)

	caso queira utilizar a tela do pygame em tela cheia, defina a palavra FULLSCREEN no segundo parâmetro, assim:

	    ex:
	        pygame.display.set_mode((width, height), FULLSCREEN, depth)

	        OBS: ao definir o segundo parâmetro de pygame.display.set_mode para FULLSCREEN, CERTIFIQUE-SE DE OFERECER UMA MANEIRA DE SAIR DO SCRIPT, POIS O BOTÃO DE FECHAMENTO NÃO ESTARÁ VISÍVEL (PQ A TELA ESTARÁ EM MODO DE TELA CHEIA)


	// Flags para pygame.display.set_mode
	    FULLSCREEN - Cria um display que preenche a tela inteira.
	    DOUBLEBUF - Cria um display "double-buffered" (com buffer duplo). Recomendado para HWSURFACE ou para OPENGL.
	    HWSURFACE - Cria um display acelerado por hardware (hardware-accelerated; deve ser combinada com a flag FULLSCREEN).
	    OPENGL - Cria um display renderizável com OpenGL.
	    RESIZABLE - Cria um display que pode ser redimensionado.
            NOFRAME - Remove a borda e a barra de título do display


	OBS: as vezes, o Pygame é incapaz de nos fornecer o display exato que pedimos. É possível que a placa de video não suporte os recursos que estamos solicitando. Felizmente, o Pygame ESCOLHERÁ UM DISPLAY QUE SEJA COMPATÍVEL COM O HARDWARE E EMULARÁ O DISPLAY que solicitamos.


    	o próximo parametro especifica a profundidade (depht) da superficie do display, que é a quantidade de bits usada para armazenar cores no display. Um bit, ou digito binário é a unidade de armazenamento fundamental em um computador. Os bits têm dois valores possíveis, 1 e 0, e estão organizados na memória em grupos de 8. Um grupo de 8 bits é chamado de 1 byte. Se vc não especificar um valor para a profundidade ou defini-la com 0, o Pygame utilizará a profundidade de seu desktop.

	// Valores de profundidade em bits
	    8 bits - 256 cores, selecionadas a partir de uma paleta maior de cores.
	    15 bits - 32.768 cores, com um bit extra.
	    16 bits - 65.536 cores.
	    24 bits - 16,7 milhões de cores.
	    32 bits - 16,7 milhões de cores, com 8 bits extras.


	Exemplo de código para DEIXAR A TELA EM TELA CHEIA e RETIRAR A TELA CHEIA COM O BOTÃO (f) DO TECLADO:
	########################################################################
	    import pygame

	    pygame.init()
	    screen = pygame.display.set_mode((640, 480), 0, 32)
	    fullscreen = False

	    while True:

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    exit()
        	if event.type == pygame.KEYDOWN:
            	    if event.key == pygame.K_f:
                        fullscreen = not fullscreen
                	if fullscreen == True:
                    	    pygame.display.set_mode((640, 480), pygame.FULLSCREEN, 32)
                        else:
                            pygame.display.set_mode((640, 480), 0, 32)


    	    pygame.display.update()	     

	##############################################################################


	JANELAS DO PYGAME QUE PODEM SER REDIMENSIONADAS
	
	    Ocasionalmente, você pode querer que o usuário seja capaz de redimensionar uma janela do Pygame, o que, normalmente, é feito ao clicar no canto da janela e arrastar com o mouse. É fácil fazer isso usando no segundo parâmetro de pygame.display.set_mode()
 a flag RESIZABLE. O Pygame informará o seu código se o usuário alterar o tamanho da janela ao enviar um evento VIDEORESIZE que contêm a nova largura e a nova altura da janela. Ao obter um desses eventos, chame pygame.display.set_mode() novamente para definir o display com as novas dimensões. A listagem 3.5 mostra como responder a eventos VIDEORESIZE.

	Exemplo de código para REDIMENSIONAR A TELA DO PYGAME
	##############################################################################
	    import pygame
	    from pygame.locals import *



	    background_image_filename = 'sushiplate.jpg'
	    SCREEN_SIZE = (640, 480)

	    pygame.init()
	    screen = pygame.display.set_mode(SCREEN_SIZE, RESIZABLE, 32)
	    background = pygame.image.load(background_image_filename).convert()

	    while True:

	        event = pygame.event.wait()

    	        if event.type == pygame.QUIT:
                    pygame.quit()
                    exit()
    	        if event.type == pygame.VIDEORESIZE:
        	    SCREEN_SIZE = event.size # event.size é uma tupla que contêm as nova dimensões da janela.
        	    screen = pygame.display.set_mode(SCREEN_SIZE, RESIZABLE, 32)
        	    pygame.display.set_caption("Window resizable to "+str(event.size))
        	    screen_width, screen_height = SCREEN_SIZE
        	    for y in range(0, screen_height, background.get_height()):
            	    for x in range(0, screen_width, background.get_width()):
                        screen.blit(background, (x, y))


            pygame.display.update() 

	##############################################################################

        Ao executar esse script, le exibirá uma hnela simples do Pygame com uma imagem de background. Se você clicar no canto ou na borda da janela e arrastar com o mouse, o script obterá um evento VIDEORESIZE. No handler dessa mensagem, há outra chamada para pygame.display.set_mode(), que criará uma nova superficie de tela correspondente ás novas dimensões. A mensagem de redimensionamento contém os seguintes valores:

		size -  é uma tupla que contém as novas dimensões da janela: size[0] é a largura e size[1] é a altura.

		w - esse valor contém a nova largura da janela. É o mesmo valor que está em size[0], porém poderá ser mais conveniente.

		h - esse valor contém a nova altura da janela. É o mesmo valor que está em size[1], porém poderá ser mais conveniente.


	Como o tamanho do display pode variar com esse script, desenhamos o background de maneira um pouco diferente ao fazer o blitting da imagem de background quantas vezes forem necessárias para posicionar essas várias imagens de background.

	A maioria dos jogos executa em tela cheia, de modo que a capacidade de redimensionar displays talvez não seja uma funcionalidade usada com muita frequência. No entanto ela estará em sua caixa de ferramentas se você precisar dela!.


	JANELAS SEM BORDAS

	    vc pode criar uma janela que não tem bordas (ou seja, o usuário não pode mover ou redimensionar a janela, nem mesmo usar o X de fechamento da janela). 

	    O comando é assim:

		##################################################################

		pygame.display.set_mode((width, height), NOFRAME, 32) 

		##################################################################


	FLAGS ADICIONAIS DE DISPLAY

	    Há mais algumas flags que podem ser usadas em uma chamada a set_mode(). Eu as considero avançadas, pois elas podem comprometer o desenpenho se forem usadas incorretamente ou podem causar problemas de compatibilidade em algumas plataformas. Geralmente, é melhor usar o valor 0 para displays com janelas e FULLSCREEN para displays de tela cheia para garantir que o seu jogo funcionará bem em todas as plataformas. Apesar do que foi dito, se souber o que está fazendo, vc poderá definir umas flags avançadas para obter um desempenho melhor. Também não há problema algum em experimentar (Não causará danos ao seu computador).

	    Se vc definir a flag HWSURFACE, essa flag criará o que chamamos de superficies de hardware. Esse é um tipo de superficie especial de display que é armazenado na memória de sua placa de video. Ele poderá ser usado somente em combinação com a flag FULLSCREEN, da seguinte maneira:


	    screen = pygame.display.set_mode((width, height), HWSURFACE | FULLSCREEN , 32)   


	    As superficies de hardware podem ser mais rápidas que as superficies criadas na memória do sistema (que é o modo normal de criação de superficies), pois elas podem tirar proveito de mais recursos de sua placa de vídeo para agilizar o blitting. A desvantagem da superficie de hardware está no fato de elas não serem tão bem suportadas em todas as plataformas. Elas tendem a funcionar nas plataformas Windows, mas não tão bem em outras plataformas. As superficies de hardware também se beneficiam com a flag DOUBLEBUF. Com essa flag, duas superficies de hardware são criadas, mas somente uma será visivel em determinado instante. A linha a seguir cria uma superficie de hardware com buffer duplo (double-buffered):

	
	     screen = pygame.display.set_mode((width, height), DOUBLEBUF | HWSURFACE | FULLSCREEN , 32)  


	    Normalmente, ao chamar pygame.display.update(), uma tela completa é copidada da memória para o display - o que pode demorar um pouco. As superfífies com buffer duplo permitem alternar instantaneamente para a nova tela e, desse modo, deixam o seu jogo um pouco mais rápido.

	    A última flag de display que podemos usar é OPENGL. A OpenGL (www.opengl.org/) é uma biblioteca gráfica que usa a aceleradora gráfica 3D, encontrada praticamente em todas as placas de vídeo. A desvantagem de usar essa flag é que você não poderá mais usar as funções gráficas 2D do pygame.


	OBS: SE VC ESTIVER USANDO UM DISPLAY COM BUFFER DUPLO, CHAME pygame.display.flip() EM VEZ DE CHAMAR pygame.display.update(). ISSO FARÁ A MUDANÇA INSTANTÂNEA DO DISPLAY EM VEZ DE EFETUAR UMA CÓPIA DOS DADOS NA TELA.

---------------------------------------------------------------------------------------

    continuação do modulo display do pygame....

    pygame.display.set_caption('Título da janela') - define o texto que fica na barra de título, na parte superior da janela.

    pygame.display.set_icon(img) - usado para mudar a logo da janela do jogo.

        ex:
	    icon = pygame.image.load('imagem.extensao')
	    pygame.display.set_icon(icon)


    pygame.display.list_modes() - usado para saber exatamente quais são as resoluções que o seu display suporta (retorna uma lista de tuplas contendo as resoluções suportadas).

		ex:
		    import pygame

		    pygame.init()
		    print("resoluções padrão suportadas pela placa de video do computador: \n", pygame.display.list_modes())


    pygame.display.update() - atualiza toda a tela do jogo, evitando o efeito flicker (que é o efeito que deixa rastros de uma animação de sprite de jogo na tela, por exemplo) caso haja uma animação na tela.


    pygame.display.Info() - exibe informações sobre a tela do pygame. Essa classe Info() POSSUI DUAS PROPRIEDADES: current_w e current_h, que SÃO USADAS PARA PEGAR AS DIMENSÕES DA TELA. Podemos usar 
    essas propriedades para criar uma janela fullscreen onde INDEPENDENTE DE QUAL DISPOSITIVO a aplicação pygame rodar, A APLICAÇÃO PEGARÁ AS DIMENSÕES DA JANELA DO DISPOSITIVO.

        ex:

            import pygame

			pygame.init()
			pygame.display.set_caption('Resize e Fullscreen')

			# definimos uma tupla com as propriedades current_w (pegará a atual largura da tela) e current_h (pegará a atual altura da tela)
			monitor_size = (pygame.display.Info().current_w, pygame.display.Info().current_h)

			screen = pygame.display.set_mode((300, 300), pygame.RESIZABLE)
			clock = pygame.time.Clock()

			fullscreen = False

			while True:

			    for event in pygame.event.get():
			        if event.type == pygame.QUIT:
			            pygame.quit()
			            exit()
			            
			        if event.type == pygame.KEYDOWN:
			            if event.key == pygame.K_ESCAPE:
			                pygame.quit()
			                exit()

	                if event.key == pygame.K_f:
		                fullscreen = not fullscreen
		                if fullscreen == True:

		                    # inserimos a tupla monitor_size na tela para gerar a tela fullscreen
		                    screen = pygame.display.set_mode(monitor_size, pygame.FULLSCREEN)
		                    print(monitor_size)
		                else:
		                    screen = pygame.display.set_mode((screen.get_width(), screen.get_height()), pygame.RESIZABLE)
		 


			    screen.fill((0, 100, 0))

			    pygame.draw.rect(screen, (255, 0, 0), pygame.Rect(screen.get_width() - 5 - (screen.get_width() / 5), 50, screen.get_width() / 5, 50))


			    pygame.display.update()
			    clock.tick(60)







----------------------------------------------------------------------

classe image do pygame

    pygame.image.load('imagem.extensão') - usado para carregar imagens para o pygame. O método load() retorna uma SUPERFÍCIE (surface) contendo os dados da imagem. Ao carregarmos uma imagem ao pygame, utilizamos o método .convert(), assim: 

	ex:
	    pygame.image.load('imagem.extensão').convert()

	assim, conseguimos CONVERTER A IMAGEM PARA O MESMO FORMATO DO DISPLAY DA TELA, pq é mais fácil desenhar as imagens se o display tiver a mesma profundidade de cores da imagem.

	OBS: Os objetos pygame.image SÃO DO MESMO TIPO que OS OBJETOS pygame.display, porêm, os objetos pygame.image SOMENTE REPRESENTAM AS IMAGENS ARMAZENADAS NA MEMÓRIA e NÃO SERÃO VISÍVEIS ATÉ QUE SEJAM DESENHADAS no DISPLAY PRINCIPAL (desenha-se com o comando: pygame.Surface.blit()), pq como a tela do jogo (que é: pygame.display.set_mode()) TBM É UMA SUPERFICIE (Surface), vc pode chamar o método blit() da classe: pygame.Surface para desenhar a imagem na tela, assim: 

	    screen.blit(img, (pos_x,pos_y))


    pygame.image.save(surface, fileName) - usado para salvar uma imagem em seu Hard Disk (HD). No primeiro parâmetro vc INSERE A SUPERFÍCIE e no segundo parâmetro vc DEFINE UM NOME COM A EXTENSÃO .png ou .jpeg. Este método salvará a superfície no HD como extensão PNG ou JPEG.

	ex:
	    my_name = "Eduardo chagas"

	    pygame.init()
	    my_font = pygame.font.SysFont("Arial", 64)
	    name_surface = my_font.render(my_name, True, (0, 0, 0), (255, 255, 255))
	    pygame.image.save(name_surface, "name.png") 	     

	 

----------------------------------------------------------------------

Classe event do pygame

    pygame.event.get() - esse método possui todos os eventos do pygame. O que  esse comando faz é armazenar todos os eventos em uma lista, retornando qualquer evento que executarmos. Utilizamos esse evento em um loop for, assim:

	for event in pygame.event.get():
	    if event.type == pygame.QUIT:
		pygame.quit() //encerra todos os módulos do pygame
		exit() //encerra o python


	    //Tipos de Eventos do pygame
	    QUIT              none
	    ACTIVEEVENT       gain, state
	    KEYDOWN           key, mod, unicode, scancode
	    KEYUP             key, mod
	    MOUSEMOTION       pos, rel, buttons
	    MOUSEBUTTONUP     pos, button
	    MOUSEBUTTONDOWN   pos, button
	    JOYAXISMOTION     joy, axis, value
	    JOYBALLMOTION     joy, ball, rel
	    JOYHATMOTION      joy, hat, value
	    JOYBUTTONUP       joy, button
	    JOYBUTTONDOWN     joy, button
	    VIDEORESIZE       size, w, h
	    VIDEOEXPOSE       none
	    USEREVENT         code


	OBS: Nem todos os eventos devem se tratados em todos os jogos e, geralmente, há maneiras alternativas de obter informações que os eventos podem oferecer. Se vc estiver usando o pygame.mouse.get_pos(), não será necessário responder ao evento MOUSEMOTION.

	
	*** Detalhes sobre o EVENTO DE MOVIMENTO DO MOUSE com MOUSEMOTION ***
	os eventos MOUSEMOTION são gerados sempre que o mouse é movido sobre a janela do Pygame. Esses eventos contêm três valores:

	    buttons - uma tupla de três números que corresponde aos botões do mouse. Desse modo, buttons[0] é o botão esquerdo do mouse, buttons[1] é o botão do meio (com uma roda do mouse) e buttons[2] é o botão direito. Se o botão estiver pressionado, seu valor estará definido como 1; se não estiver pressionado, o valor será 0. Vários botões poderão estar pressionados ao mesmo tempo.

	    pos - uma tupla que contém a posição do mouse quando o evento foi gerado.

	    rel - uma tupla que contém a distância que o mouse percorreu desde o último evento de movimento do mouse (as vezes é chamado de mickies do mouse).


	    
	*** Detalhes sobre o EVENTO DE BOTÕES DO MOUSE com MOUSEBUTTOMDOWN e MOUSEBUTTOMUP ***
	se vc clicar no mouse, gerará o evento 'down', se em seguida vc soltar o botão do mouse, gerará o evento 'up'. Ambos os tipos de eventos do botão do mouse (MOUSEBUTTOMDOWN e MOUSEBUTTOMUP) contêm os dois valores a seguir:

	    button - é o número do botão pressionado. Um valor igual a 1 indica que O BOTÃO ESQUERDO DO MOUSE foi pressionado. O valor 2 indica que O BOTÃO DO MEIO foi pressionado e o valor 3 indica que O BOTÃO DIREITO foi pressionado. 

	    pos - uma tupla que contém a posição do mouse quando o evento foi gerado.



	*** Detalhes sobre o EVENTO DE TECLAS DO TECLADO com KEYDOWN e KEYUP ***
	os eventos de teclado possui três valores:

	key - é UM NÚMERO que REPRESENTA A TECLA PRESSIONADA ou LIBERADA. Cada TECLA FÍSICA DO TECLADO TEM UMA CONSTANTE associada QUE COMEÇA COM K_. As teclas para letras do alfabeto vão de K_a a K_z, porém HÁ TAMBÉM CONSTANTES PARA TODAS AS  DEMAIS TECLAS, por exemplo, K_SPACE e K_RETURN. Para ver uma lista completa das constantes de teclas que podem ser usadas, dê uma olhada na tabela de constantes retiradas da documentação oficial:

			pygame
		Constant      ASCII   Description
		---------------------------------
		K_BACKSPACE   \b      backspace
		K_TAB         \t      tab
		K_CLEAR               clear
		K_RETURN      \r      return
		K_PAUSE               pause
		K_ESCAPE      ^[      escape
		K_SPACE               space
		K_EXCLAIM     !       exclaim
		K_QUOTEDBL    "       quotedbl
		K_HASH        #       hash
		K_DOLLAR      $       dollar
		K_AMPERSAND   &       ampersand
		K_QUOTE               quote
		K_LEFTPAREN   (       left parenthesis
		K_RIGHTPAREN  )       right parenthesis
		K_ASTERISK    *       asterisk
		K_PLUS        +       plus sign
		K_COMMA       ,       comma
		K_MINUS       -       minus sign
		K_PERIOD      .       period
		K_SLASH       /       forward slash
		K_0           0       0
		K_1           1       1
		K_2           2       2
		K_3           3       3
		K_4           4       4
		K_5           5       5
		K_6           6       6
		K_7           7       7
		K_8           8       8
		K_9           9       9
		K_COLON       :       colon
		K_SEMICOLON   ;       semicolon
		K_LESS        <       less-than sign
		K_EQUALS      =       equals sign
		K_GREATER     >       greater-than sign
		K_QUESTION    ?       question mark
		K_AT          @       at
		K_LEFTBRACKET [       left bracket
		K_BACKSLASH   \       backslash
		K_RIGHTBRACKET ]      right bracket
		K_CARET       ^       caret
		K_UNDERSCORE  _       underscore
		K_BACKQUOTE   `       grave
		K_a           a       a
		K_b           b       b
		K_c           c       c
		K_d           d       d
		K_e           e       e
		K_f           f       f
		K_g           g       g
		K_h           h       h
		K_i           i       i
		K_j           j       j
		K_k           k       k
		K_l           l       l
		K_m           m       m
		K_n           n       n
		K_o           o       o
		K_p           p       p
		K_q           q       q
		K_r           r       r
		K_s           s       s
		K_t           t       t
		K_u           u       u
		K_v           v       v
		K_w           w       w
		K_x           x       x
		K_y           y       y
		K_z           z       z
		K_DELETE              delete
		K_KP0                 keypad 0
		K_KP1                 keypad 1
		K_KP2                 keypad 2
		K_KP3                 keypad 3
		K_KP4                 keypad 4
		K_KP5                 keypad 5
		K_KP6                 keypad 6
		K_KP7                 keypad 7
		K_KP8                 keypad 8
		K_KP9                 keypad 9
		K_KP_PERIOD   .       keypad period
		K_KP_DIVIDE   /       keypad divide
		K_KP_MULTIPLY *       keypad multiply
		K_KP_MINUS    -       keypad minus
		K_KP_PLUS     +       keypad plus
		K_KP_ENTER    \r      keypad enter
		K_KP_EQUALS   =       keypad equals
		K_UP                  up arrow
		K_DOWN                down arrow
		K_RIGHT               right arrow
		K_LEFT                left arrow
		K_INSERT              insert
		K_HOME                home
		K_END                 end
		K_PAGEUP              page up
		K_PAGEDOWN            page down
		K_F1                  F1
		K_F2                  F2
		K_F3                  F3
		K_F4                  F4
		K_F5                  F5
		K_F6                  F6
		K_F7                  F7
		K_F8                  F8
		K_F9                  F9
		K_F10                 F10
		K_F11                 F11
		K_F12                 F12
		K_F13                 F13
		K_F14                 F14
		K_F15                 F15
		K_NUMLOCK             numlock
		K_CAPSLOCK            capslock
		K_SCROLLOCK           scrollock
		K_RSHIFT              right shift
		K_LSHIFT              left shift
		K_RCTRL               right control
		K_LCTRL               left control
		K_RALT                right alt
		K_LALT                left alt
		K_RMETA               right meta
		K_LMETA               left meta
		K_LSUPER              left Windows key
		K_RSUPER              right Windows key
		K_MODE                mode shift
		K_HELP                help
		K_PRINT               print screen
		K_SYSREQ              sysrq
		K_BREAK               break
		K_MENU                menu
		K_POWER               power
		K_EURO                Euro


	mod - esse valor representa as teclas usadas em combinação com outras teclas, por exemplo, Shift, Alt e Ctrl. Cada uma dessas teclas modificadoras é representada por uma constante que começa com KMOD_, por exemplo, KMOD_SHIFT, KMOD_ALT e KMOD_CTRL. Teste esses valores usando o operador bitwise AND (E bit a bit, que é o caractere (&) do teclado). Por exemplo, mod & KMOD_CTRL será avaliado como True se a tecla Ctrl estiver pressionada. Veja a lista completa das teclas modificadoras:

			    pygame
		Constant      Description
		-------------------------
		KMOD_NONE     no modifier keys pressed
		KMOD_LSHIFT   left shift
		KMOD_RSHIFT   right shift
		KMOD_SHIFT    left shift or right shift or both
		KMOD_LCTRL    left control
		KMOD_RCTRL    right control
		KMOD_CTRL     left control or right control or both
		KMOD_LALT     left alt
		KMOD_RALT     right alt
		KMOD_ALT      left alt or right alt or both
		KMOD_LMETA    left meta
		KMOD_RMETA    right meta
		KMOD_META     left meta or right meta or both
		KMOD_CAPS     caps lock
		KMOD_NUM      num lock
		KMOD_MODE     mode


	unicode - é o valor Unicode da tecla pressionada. Ela é gerada pela combinação da tecla pressionada com qualquer uma das teclas modificadoras pressionada. Há um valor Unicode para cada símbolo do alfabeto inglês e de outros idiomas. Você não usará esse valor com frequência em um jogo, pois as teclas temdem a ser usadoas mais como chaves (switches) do que para entrada de atexto. Uma exceção será a inserção em uma tabela das maiores pontuações, em que vovê vai querer que o jogador possa difitar letras que não pertençam ao alfabeto inglês, bem como misturar letras maiúsculas e minúsculas.


    pygame.event.wait() - usado para parar uma ação até que algum evento ocorra (esse método não é muito usado em jogos pq ela suspende o script até que algo ocorra, mas pode ser útil em aplicações Pygame que trabalhem em conjunto com outros programas em seu sistema. Por exemplo, os players de mídia).

    pygame.event.poll() - retorna um único evento se ouver algum esperando.


    pygame.event.set_blocked(eventType) - usado para bloquear eventos (ex: MOUSEMOTION, KEYDOW, etc...) do jogo. Essa função aceita um único tipo de evento ou uma lista de tipos de evento. Se uma lista de tipos de eventos for passada, todos esses eventos dessa lista serão bloqueados. Para darmos um exemplo, imagina uma cena de um filme reproduzida entre os níveis do jogo, é provável que você vá querer ignorar os eventos até que a cena tenha terminado.

        ex:
	    pygame.event.set_blocked(MOUSEMOTION)


	OBS: se vc quiser fazer o contrário (DESBLOQUEAR OS EVENTOS BLOQUEADOS) passe o valor (None) como parâmetro em set_blocked(), assim:

        ex:
	    pygame.event.set_blocked(None) 



    pygame.event.set_allowed() - usado para desbloquear eventos (ex: MOUSEMOTION, KEYDOW, etc...) do jogo. Essa função aceita um único tipo de evento ou uma lista de tipos de evento. Se uma lista de tipos de eventos for passada, todos esses eventos dessa lista serão desbloqueados.

        ex:
	    pygame.event.set_allowed([KEYUP, KEYDOWN])


	OBS: se vc quiser fazer o contrário (BLOQUEAR OS EVENTOS DESBLOQUEADOS) passe o valor (None) como parâmetro em set_blocked(), assim:

	ex:
	    pygame.event.set_allowed(None) 


    pygame.event.get_block() - usado para perguntar ao Pygame se um evento está bloqueado no momento que usarmos esse método (ESSE MÉTODO ACEITA SOMENTE UM ÚNICO TIPO DE EVENTO).


    pygame.event.Event(EVENT, dict) - usado para simular eventos gerados pelo pygame e/ou criar um evento personalizado no código do jogo. Para criar um evento personalizado, inicialmente crie um evento com pygame.event.Event() e poste-o com pygame.event.post(). O evento será inserido no final da fila de eventos e estará pronto para ser obtido pelo loop de eventos. 

    Vamos ver UM EXEMPLO DE COMO SIMULAR O JOGADOR PRESSIONANDO A TECLA barra de espaço:

    ex:
	my_event = pygame.event.Event(KEYDOWN, {"key":K_SPACE})
        pygame.event.post(my_event)

	OBS: O LIVRO MOSTRA COMO CONFIGURAR O EVENTO DE SIMULAÇÃO DE PRESSIONAMENTO DE TECLA, MAS NÃO ENSINA A COMO IMPLEMENTAR ISSO NO CÓDIGO.


    Agora vamos ver UM EXEMPLO DE COMO CRIAR UM EVENTO PERSONALIZADO no pygame:

    ex:
	CATONKEYBOARD = USEREVENT+1
	my_event = pygame.event.Event(CATONKEYBOARD, message="Bad Cat!")
        pygame.event.post(my_event)

	for event in pygame.event.get():
	    if event.type == CATONKEYBOARD:
		print(event.message)

        OBS: O LIVRO MOSTRA COMO CONFIGURAR O EVENTO DE SIMULAÇÃO DE PRESSIONAMENTO DE TECLA, MAS NÃO ENSINA A COMO IMPLEMENTAR ISSO NO CÓDIGO.
	

    pygame.event.post(EVENT) - Coloca o evento (especificado no parâmetro) no final da fila de eventos.



  
----------------------------------------------------------------------
	
módulo font do pygame 

 O módulo de fontes usa fontes True Type (.ttf) utilizadas na maioria dos sistemas para renderizar um texto regular e de alta qualidade. Haverá muitas dessas fontes instaladas em seu computador, e elas poderão ser usadas pelo módulo de fontes.

	OBS: OS OBJETOS FONT TBM SÃO SUPERFICIES, ASSIM COMO AS IMAGENS E O DISPLAY DA TELA.

    
    pygame.font.SysFont(font, size) - usado para pegar uma fonte instalada em seu computador. No primeiro parâmetro vc insere o nome da fonte instalada em seu Sistema Operacional, e no segundo parâmetro vc insere o tamanho da fonte. O exemplo abaixo pega a fonte "Arial" do seu sistema (a fonte "Arial" é uma fonte existente em todos os sistemas operacionais).

	ex:
	    pygame.font.SysFont("Arial", 16)


	OBS: O PYGAME PROCURARÁ UMA FONTE DE NOME "Arial" EM SUAS FONTES INSTALADAS; SE NÃO ENCONTRÁ-LA, UMA FONTE DEFAULT SERÁ RETORNADA. VOCÊ PODERÁ OBTER UMA LISTA DE FONTES INSTALADAS EM SEU SISTEMA AO CHAMAR pygame.font.get_fonts(). 


    pygame.font.Font(nomeDoArquivo_ttf, size) - usado para trabalhar com um arquivo (.ttf, que são arquivos de fontes). O primeiro parâmetro vc insere o nome do arquivo (nomeDoArquivo.ttf), e no segundo parâmetro, vc insere o tamanho da fonte (que é um número).

	ex:
	    my_font = pygame.font.Font("Mansalva.ttf", 40)


	    OBS: Mansalva.ttf É O NOME DE UMA FONTE, É SÓ PROCURAR NA INTERNET.


	        Após ter criado um objeto Font, ele porerá ser usado para RENDERIZAR UM TEXTO em uma NOVA SUPERFÍCIE. Para renderizar um texto, utilize a função-membro render() dos objetos Font. Ela CRIA UMA NOVA SUPERFÍCIE CONTENDO O TEXTO e vc poderá fazer o seu blitting no display. A linha a seguir renderiza um texto curto e retorna uma nova superfície:


		text_surface = my_font.render('Pygame is cool', True, (0, 0, 0), (255, 255, 255))


		OBS: OS MÉTODOS DE FONTES SÃO UTILIZADOS TANTO PARA OS OBJETOS Font() QUANTO PARA OS OBJETOS SysFont().


		O PRIMEIRO PARÂMETRO do método render() É O TEXTO QUE VOCÊ DESEJA RENDERIZAR. Esse parâmetro deve corresponder a uma única linha; se quiser ter várias linhas, você deverá dividir a string e usar várias chamadas a render(). O SEGUNDO PARÂMETRO é um booleano (True ou False) USADO PARA HABILITAR UM TEXTO COM 'anti-aliasing'. Se definido como True, o texto terá uma aparência suave e moderna; caso contrário, ele parecerá ter os pixels mais evidentes. O TERCEIRO PARÂMETRO do método render() DEFINE A COR DO TEXTO e o QUARTO PARÂMETRO define A COR DE FUNDO DO TEXTO. A cor de fundo é opcional; Se vc especifica-la (ou defini-la com o valor None), a cor de fundo será transparente.

		
		vamos agora criar um pequeno script para renderizar o seu nome em uma superfície e salva-la como uma imagem. 

		    import pygame


		    my_name = "Eduardo chagas"

		    pygame.init()
		    my_font = pygame.font.SysFont("Arial", 64)
		    name_surface = my_font.render(my_name, True, (0, 0, 0), (255, 255, 255))
		    pygame.image.save(name_surface, "name.png")  		 

		
		Esse script é tão simples que não precisamos nem mesmo criar um display! Ao executar esse script, você não verá muita atividade na tela, porém o código cria um arquivo de imagem chamado "name.png" no mesmo local em que estiver o seu script. A superfície é salvada em um arquivo usando o módulo pygame.image (que é o módulo de imagens do Pygame).


		O módulo de fontes disponibiliza outras funçoes (que são os métodos), assim como os objetos Font (que são os objetos criados com o método Font), que, ocasionalmente, você precisará usar. Eles são, em sua maior parte, informativos, e foram concebidos para retornar diversar informações relacionadas a fontes. Há funções (no módulo Font do Pygame) que simulam textos em negrito (como por exemplo: pygame.font.Font.set_bolt) 
e funções que simulam textos em itálico (como por exemplo: pygame.font.Font.set_italic). Porém é melhor usar uma fonte dedicada (usar arquivos com extensão (.ttf)) para negrito e para itálico.
 

 
    pygame.font.get_fonts() - retorna uma lista de todas as fontes instaladas no sistema (usado para saber quais são as fontes instaladas no seu Sistema Operacional).



----------------------------------------------------------------------------------

módulo rect do pygame

    pygame.Rect(x, y, width, height) - objeto pygame para armazenar coordenadas retângulares.

        OBS: OS OBJETOS Rect() SÃO USADOS COM TANTA FREQUÊNCIA QUE ESTÃO INCLUIDOS EM pygame.locals - PORTANTO, SE VOCÊ TIVER: from pygame.locals import * NO INÍCIO DE SEU SCRIPT, NÃO SERÁ NECESSÁRIO USAR O NOME DE UM MÓDULO (por exemplo: pygame.Rect()) COMO PREFIXO.

	OBS2: vc pode definir os parâmetros de Rect() com tuplas, assim: Rect((x,y),(width, height)).


    

	 

----------------------------------------------------------------------------------

módulo draw do pygame

 O módulo draw do pygame é usado para desenhar formas geométricas na tela do pygame.

    pygame.draw.rect(surface, color, rect, width) - usado para desenhar retângulo na tela do pygame. O primeiro parâmetro vc insere uma superfície. No segundo parâmetro vc insere uma cor, e no terceiro parâmetro vc insere o retângulo. O QUARTO PARÂMETRO É OPCIONAL, se Width for definido com zero ou omitido, o retângulo será preenchido com uma cor sólida; caso contrário, somente as bordas serão desenhadas com uma determinada grossura dependendo do número inserido em width.  


    pygame.draw.polygon(surface, color, listPoints, width) - usado para desenhar uma forma (forma de vários lados, 3, 4, 5 lados ou mais) na tela do pygame. Essa forma pode ser qualquer forma, de um triângulo a um polígono de mil lados (ou mais). o parâmetro listPoints é a lista de coordenadas (x, y) usadas para desenhar na tela. Essa função tbm aceita um valor width opicional. Se width for omitido ou se for definido com zero, o polígono será preenchido; caso contrário, somente as bordas serão desenhadas.

	ex:
	    import pygame
	    from pygame.locals import *
	    from sys import exit
	    from random import *

	    pygame.init()
	    screen = pygame.display.set_mode((640, 480), 0, 32)

	    points = []

	    while True:
       	        for event in pygame.event.get():
        	    if event.type == pygame.QUIT:
                        pygame.quit()
            		exit()

        	    if event.type == MOUSEBUTTONDOWN:
            		points.append(event.pos)

    		screen.fill((255, 255, 255))

    		if len(points) >= 3:
        	    pygame.draw.polygon(screen, (0, 255, 0), points)
    		for point in points:
       		    pygame.draw.circle(screen, (0, 0, 255), point, 5)

    		pygame.display.update()



    pygame.draw.circle(surface, color, posXYDoCentroDoRaio, raio, width) - usado para desenhar um circulo em uma superfície (como por exemplo, a tela) no pygame. Esse método aceita o ponto central e o raio do círculo (o raio é a distância do centro até a borda). Como as demais funções de desenho, essa função aceita um valor para a espessura da linha. Se width for zero ou se for omitido, o círculo será desenhado com uma linha; caso contrário, o círculo será sólido.
	
	ex:
	    import pygame
	    from pygame.locals import *
	    from sys import exit
	    from random import *


	    pygame.init()
	    screen = pygame.display.set_mode((640, 480), 0, 32)

	    # definindo a cor
	    GREEN = (0, 50, 0)
	    RED = (255, 0, 0)

	    posicaoInicialX_Y = (250, 150) # definindo a posição inicial do circulo na tela.
	    radius = 60 # definindo a área de alcance do raio



	    while True:
    	        for event in pygame.event.get():
        	    if event.type == pygame.QUIT:
            	        pygame.quit()
            		exit()

    		screen.fill(GREEN)

    		pygame.draw.circle(screen, RED, posicaoInicialX_Y, radius)


    		pygame.display.update()



    pygame.draw.ellipse(surface, cor, Rect(left, top, width, height), width=0) - usado para desenhar uma elipse em uma superfície (como por exemplo, na tela do jogo). O terceiro parâmetro aceita um retângulo que define a área retângular onde a elipse será desenhada. Esse método tbm têm um parâmetro width, se width for zero ou se for omitido, a elipse será desenhada com uma linha; caso contrário, a elipse será sólida.

    	ex:
    		import pygame
			from pygame.locals import *
			from sys import exit
			from random import *


			pygame.init()
			screen = pygame.display.set_mode((640, 480), 0, 32)

			# definindo a cor
			RED = (255, 0, 0)


			while True:
			    for event in pygame.event.get():
			        if event.type == pygame.QUIT:
			            pygame.quit()
			            exit()

			    screen.fill(GREEN)

			    pygame.draw.ellipse(screen, RED, (50, 50, 200, 100)) # desenhando uma elipse

			    pygame.display.update()



    pygame.draw.arc(surface, color, rect, start_angle, stop_angle, width) - desenha o arco inteiro ou somente parte do arco. Esse método desenha somente a borda do arco e não há opção de preenchimento para esse método. Esse método aceita um objeto do tipo Rect() que define a área onde o arco será desenhado. A função tbm aceita dois ângulos em radianos. O primeiro ângulo é o local em que o desenho do arco deve iniciar e o segundo é o local onde o desenho deve terminar. Esse método tbm aceita um parâmetro width=1 para a linha cujo o padrão é 1, porém pode ser definido com valores maiores para que a linha seja mais espessa.




    pygame.draw.line(surface, color, start_pos, end_pos, width) - usado para desenhar uma linha entre dois pontos. além dos parâmetros de superfície e de cor, esse método aceita dois parâmetros: a posição inicial da linha e a posição final da linha que vc quer desenhar. Há tbm o parâmetro width opcional, se width for zero ou se for omitido, a linha será desenhada normalmente; caso contrário, a linha ficará mais grossa.

		ex:
			import pygame
			from pygame.locals import *
			from sys import exit
			from random import *
			from math import pi


			pygame.init()
			screen = pygame.display.set_mode((640, 480), 0, 32)

			# definindo a cor
			RED = (255, 0, 0)
			WHITE = (255, 255, 200)


			posInicial = (50, 50) # posição inicial para desenhar a linha
			posFinal = (150, 150) # posição final para desenhar a linha


			while True:
			    for event in pygame.event.get():
			        if event.type == pygame.QUIT:
			            pygame.quit()
			            exit()

			    screen.fill(WHITE)
			    pygame.draw.line(screen, RED, posInicial, posFinal, 10) # desenhando a linha


			    pygame.display.update()



    pygame.draw.lines(surface, color, closed, points, width) - usado para desenhar linhas no Pygame. no primeiro parâmetro inserimos uma superfície, no segundo parâmetro inserimos uma cor, no terceiro parâmetro inserimos um booleano True ou False, se inserir True, uma linha será desenhada entre o último ponto e o primeiro ponto. Se definido como False, não haverá linha de fechamento entre o primeiro e o último ponto definido. O método width=1 é opcional, se width for 1 ou se for omitido, a linha será desenhada normalmente; se definido com valor maior que 1, a linha ficará mais grossa.

        OBS: O EXEMPLO ABAIXO UTILIZA pygame.draw.lines() PARA DESENHAR LINHAS A PARTIR DE UMA LISTA DE PONTOS OBTIDA DE ACORDO COM A POSIÇÃO DO MOUSE. QUANDO HOUVER MAIS DE CEM PONTOS NA LISTA, O PRIMEIRO SERÁ APAGADO, DE MODO QUE A LINHA COMEÇARÁ MIRACULOSAMENTE A SE "APAGAR"!. ESSE PODE SER UM BOM PONTO DE PARTIDA PARA UM JOGO DE COBRINHA.

        ex:
            import pygame
            from pygame.locals import *
            from sys import exit

            pygame.init()
            screen = pygame.display.set_mode((640, 480), 0, 32)

            points = []

            while True:

                for event in pygame.event.get():
                    if event.type == pygame.QUIT:
                        pygame.quit()
                        exit()

                    if event.type == MOUSEMOTION:
                        points.append(event.pos)
                        if len(points) > 100:
                            del points[0]

                screen.fill((255, 255, 255))

                if len(points) > 1:
                    pygame.draw.lines(screen, (0, 255, 0), False, points, 2)

                pygame.display.update()



    pygame.draw.aaline(surface, color, start_pos, end_pos, width) - usado para desenhar uma linha entre dois pontos (COM O EFEITO ANTI-ALIASING). além dos parâmetros de superfície e de cor, esse método aceita dois parâmetros: a posição inicial da linha e a posição final da linha que vc quer desenhar. Há tbm o parâmetro width opcional, se width for zero ou se for omitido, a linha será desenhada normalmente; caso contrário, a linha ficará mais grossa.

        OBS: a desvantagem das linhas com anti-aliasing é que elas demoram mais para serem desenhadas do que as linhas sem anti-aliasing, demoram mais para serem desenhadas, mas nem tanto assim. Utilize pygame.draw.aaline() sempre que a qualidade visual for importante.

        ex:

			import pygame
			from pygame.locals import *
			from sys import exit
			from random import *
			from math import pi


			pygame.init()
			screen = pygame.display.set_mode((640, 480), 0, 32)

			# definindo a cor
			RED = (255, 0, 0)
			WHITE = (255, 255, 200)


			while True:
			    for event in pygame.event.get():
			        if event.type == pygame.QUIT:
			            pygame.quit()
			            exit()

			    screen.fill(WHITE)

			    mouse_pos = pygame.mouse.get_pos()

			    for x in range(0, 640, 20):
			        pygame.draw.aaline(screen, (0, 0, 0), (x, 0), mouse_pos)
			        pygame.draw.aaline(screen, (0, 0, 0), (x, 479), mouse_pos)

			    for y in range(0, 480, 20):
			        pygame.draw.aaline(screen, (0, 0, 0), (0, y), mouse_pos)
			        pygame.draw.aaline(screen, (0, 0, 0), (639, y), mouse_pos)

			    pygame.display.update()



    pygame.draw.aalines(surface, color, start_pos, end_pos, width) - usado para desenhar linhas no Pygame (COM O EFEITO ANTI-ALIASING). no primeiro parâmetro inserimos uma superfície, no segundo parâmetro inserimos uma cor, no terceiro parâmetro inserimos um booleano True ou False, se inserir True, uma linha será desenhada entre o último ponto e o primeiro ponto. Se definido como False, não haverá linha de fechamento entre o primeiro e o último ponto definido. O método width=1 é opcional, se width for 1 ou se for omitido, a linha será desenhada normalmente; se definido com valor maior que 1, a linha ficará mais grossa.





----------------------------------------------------------------------------

módulo time do Pygame


    pygame.time.Clock() - Cria um objeto Clock que pode ser usado para trackear (controlar) uma quantidade de tempo. O objeto clock também fornece muitas funçoes para ajudar a controlar a taxa de frames do jogo.

        ex:
            pygame.init()
            screen = pygame.display.set_mode((640, 480))
            clock = pygame.time.Clock()

        OBS: O objeto pygame.time.Clock() deve ser criado fora do loop do jogo.



        	=======================================
        	Métodos do objeto pygame.time.Clock()
        	=======================================

		        pygame.time.tick(framerate) - Essa função retorna o tempo em milissegundos, decorrido desde a chamada anterior (só para melhor entendimento, há 1.000 milissegundos em 1 segundo). Este método deve ser chamado uma vez por frame. Isso irá computar quantos milisegundos se passou desde a última chamada.

		            ex:
		            	pygame.init()
		            	screen = pygame.display.set_mode((640, 480))
		            	clock = pygame.time.Clock() # cria o objeto Clock


		                while True:
		    			    for event in pygame.event.get():
		        
		        			    if event.type == pygame.QUIT:
		            				pygame.quit()
		            				exit()

		    				screen.blit((255, 0, 0)), (0, 0))

		    				clock.tick(30) # define os frames do jogo (a 30.000 milissegundos)
		    				pygame.display.update()


		    		OBS: CASO QUEIRA CONVERTER OS MILISSEGUNDOS PARA SEGUNDOS, BASTA FAZER UMA DIVISÃO POR 1000.

		    		    ex:
		    		        pygame.init()
		            		screen = pygame.display.set_mode((640, 480))
		            		clock = pygame.time.Clock() # cria o objeto Clock


		                	while True:
		    			    	for event in pygame.event.get():
		        
		        			    	if event.type == pygame.QUIT:
		            					pygame.quit()
		            					exit()

		    					screen.blit((255, 0, 0)), (0, 0))

		    				    frame_em_milissegundos = clock.tick(30)
		    		      		frame_em_segundos = frame_em_milissgundos / 1000 # converte milissegundos para segundos

		    		      		pygame.display.update()
		    		       



---------------------------------------------------------------------------------

módulo transform do pygame

	pygame.transform.flip(Surface, xbool, ybool)) - inverte o lado de uma superficie na 
	 posição x e y, ou somente inverte na posição x, ou somente inverte na posição y.

	pygame.transform.scale(Surface, (Width, Height)) - altera a escala de exibição da imagem,
	 podendo deixar a imagem distorcida.

	pygame.transform.rotate(Surface, valorAngle) - rotaciona a imagem em um determinado angulo.  



---------------------------------------------------------------------------------



##########################################################
#														 #
#    Sessão Para entender como funciona os Vetores       #
#														 #
##########################################################

====================================
Entendendo como funciona os Vetores
====================================

    Os Vetores são semelhantes aos pontos que desenhamos no Pygame no que diz respeito ao fato de ambos terem um valor para x e para y (em 2D), porém eles são usados para propósitos deferentes. Um ponto na coordenada (10, 20) sempre será o mesmo ponto na tela, porém UM VETOR IGUAL A (10, 20) QUER DIZER SOMAR 10 Á COORDENADA x E 20 A COORDENADA Y A PARTIR DA POSIÇÃO ATUAL (ou seja, A PARTIR DO PONTO ATUAL). 

    Podemos calcular um vetor A PARTIR DE DOIS PONTOS QUAISQUER AO SUBTRAIR OS VALORES (X, Y) DO PRIMEIRO PONTO COM OS VALORES (X, Y) DO SEGUNDO PONTO. Vamos mostrar isso com um exemplo de um jogo fictício. O Personagem que representa o jogador - um soldado do futuro, aperfeiçoado cibernéticamente, chamado Alpha - deve destruir um androide-sentinela da classe Beta com um rifle sniper. Alpha está escondido atrás de um arbusto na coordenada A (10, 20) e está mirando Beta que está na coordenada B (30, 35). PARA CALCULAR UM Vetor AB ATÉ O ALVO, Alpha DEVE SUBTRAIR OS COMPONENTES de A DOS COMPONENTES de B. Desse modo, O CALCULO DO Vetor A COM O Vetor B SERÁ (30, 35) - (10, 20), QUE É (20, 15). Isso nos informa que, para ir do ponto A ao ponto B, devemos avançar 20 unidades na direção X e 15 unidades na direção Y (VEJA NO EXEMPLO ABAIXO). O jogo precisará dessa informação para fazer a animação do projétil de uma arma ou para desenhar um raio laser entre os dois pontos.


        ex:

	        					 (30,35) ponto B
	        					.
	        				  .
	        			    .
	        		      . (20,15) Vetor
	        		    .
	        	      .
	        	    .
	        	  .
	     ponto A (10,20)




	    Exemplo de calculo de vetor a partir de pontos:

	        ex:
	            import math

                class Vector():

                    def __init__(self, x=0, y=0)

                        self.x = x
                        self.y = y

                    def __str__(self):

                        return "(%s, %s)" %(self.x, self.y)

                    def from_points(P1, P2):

                        return Vector2 ( P2[0] - P2[0], P2[1] - P1[1] )



-----------------------------------------------------------------------------
========================
Magnitude de um Vetor
========================
    A magnitude de um vetor de A e B é O VALOR DA DISTÂNCIA que existe ENTRE ESSES DOIS PONTOS. Prosseguindo com o tema do cibersoldado, Alpha tem uma quantidade limitada de energia e deve calcular a distância de A e B para saber se ele consegue chegar até B. Já calculamos  o vetor AB como (20, 15). A magnitude nos dará a distância que ele deverá percorrer.

    Para calcular a magnitude de um vetor, calcule o quadrado dos componentes, some-os (x + y) e, em seguida, calcule a raiz quadrada do resultado. Desse modo a magnitude de um vetor (20, 15) será a raiz quadrada de 20*20 + 15*15, que é 25 (veja o exemplo abaixo).

        ex:


	        					         (30,35) ponto B
	        					            .
	        				            .   |
	        			            .       |
	        		            . (20,15)   | 15.0
	        		        .      Vetor    |
	        	        .					|
	        	    .						|
	        	. --------------------------
	     ponto A (10,20)       20.0


	    OBS: a magnitude (ou seja, a distância a ser percorrida) entre (20, 15) é 25.



	    Exemplo de classe para calcular a magnitude de um vetor:
	    
	        ex:
	            import math

                class Vector():

                    def __init__(self, x=0, y=0)

                        self.x = x
                        self.y = y

                    def __str__(self):

                        return "(%s, %s)" %(self.x, self.y)

                    def from_points(P1, P2):

                        return Vector2 ( P2[0] - P2[0], P2[1] - P1[1] )

                    def get_magnitude(self):

                        return math.sqrt( self.x**2 + self.y**2 )


                A = (10.0, 20.0)
                B = (30.0, 35.0)

                AB = Vector2.from_points(A, B)
                print(AB)
                print(AB.get_magnitude())

                (20.0, 15.0) # resultado do print(AB)

                25.0 # resultado do print(AB.get_magnitude())



-----------------------------------------------------------------------------
==================
Valores unitários
==================
    Os vetores, na realidade, descrevem dois aspectos: a magnitude e a direção. Por exemplo, o soldado Alpha pode usar o vetor AB para descobrir a distância que ele deve percorrer (a magnitude), mas o vetor também lhe informa a direção que ele deverá seguir (direção). Normalmente, essas duas informações estão associadas a um vetor, porém, ás vezes, somente uma delas será necessária. já vimos como calcular a magnitude, mas podemos também remover a informação de magnitude do vetor ao dividir os seus componentes pela magnitude. Isso se chama NORMALIZAR o vetor e gera um tipo especial de vetor chamado VETOR UNITÁRIO. Os vetores unitários sempre têm comprimento igual a 1 e geralmente são usados para representar uma direção. Quando nos movermos pela terceira dimensão (3D), vc os achará essenciais para tudo, de detecção de colisão á iluminação.

        exemplo de código para vetor unitário:

            ex:
                import math

                class Vector():

                    def __init__(self, x=0, y=0)

                        self.x = x
                        self.y = y

                    def __str__(self):

                        return "(%s, %s)" %(self.x, self.y)

                    def from_points(P1, P2):

                        return Vector2 ( P2[0] - P2[0], P2[1] - P1[1] )

                    def get_magnitude(self):

                        return math.sqrt( self.x**2 + self.y**2 )

                    def normalize(self):

                        magnitude = self.get_magnitude()
                        self.x /= magnitude
                        self.y /= magnitude 

                A = (10.0, 20.0)
                B = (30.0, 35.0)

                AB = Vector2.from_points(A, B)
                print("Vector AB is", AB)
                print("Magnitude of Vector AB is", AB.get_magnitude())
                AB.normalize()
                print("Vector AB normalized is", AB)

                
                # A execução do script gera o resultado a seguir:
                
                Vector AB is (20.0, 15.0)
                Magnitude of Vector AB is 25.0
                Vector AB normalized is (0.8, 0.6)



----------------------------------------------------------------------
======================
Soma de vetores
======================

	A soma de vetores combina dois vetores para gerar um unico vetor que tenha o efeito combinado de ambos. Vamos supor que o soldado Alpha deva se encontrar com um mensageiro no ponto C (15, 45) após obter o que quer que o androide no ponto B estivesse guardando. O vetor de B  para C é (-15, 10), o que significa que ele deve retroceder 15 unidades na direção x e seguir 5 unidades para a frente na direção y. Se somarmos os componentes do vetor BC ao vetor AB, vamos obter um vetor que nos levará de A a C (veja no exemplo dessa sessão).

	Para incluirmos a soma de vetores em nossa biblioteca de vetores, poderiamos criar um método chamado add e, em seguida, chamar AB.add(BC) para retornar o resultado da soma de AB e BC, porém seria mais natural se pudéssemos simplesmente chamar AB + BC. O Python oferece uma maneira de fazer isso. Ao definir um método especial chamado __add__, podemos fazer com que o Python saiba como somar duas intâncias de Vector2. Quando o Python vir AB+BC, ele tentará chamar AB.__add__(BC), portanto devemos definir __add__ para que retorne um novo objeto contendo o resultado do cálculo. Isso é conhecido como SOBRECARCA DE OPERADOR (operator oveloading). Há métodos especiais semelhantes para todos os operadores básicos, por exemplo, __sub__ para subtrair (-) e __mult__ para multiplicar (*). O exemplo do código estende a classe de vetor com um método __add__.

	    ex:

		    		ponto C  
		    	   (15, 45) / \
		    	   		   /    \
		    	   		  /       \
		    	   		 /          \
		    	   		/             \
		    	       /              / ponto C          
		    	      /            /    (30, 35)
		    	     /          /
		    	    /        /  
		           /      /
		 ponto A  /    /  
		 (10, 20)  /



		Exemplo de código para Soma de Vetores:

            ex:
                import math

                class Vector2():

                    def __init__(self, x=0, y=0)

                        self.x = x
                        self.y = y

                    def __str__(self):

                        return "(%s, %s)" %(self.x, self.y)

                    def from_points(P1, P2):

                        return Vector2 ( P2[0] - P2[0], P2[1] - P1[1] )

                    def get_magnitude(self):

                        return math.sqrt( self.x**2 + self.y**2 )

                    def normalize(self):

                        magnitude = self.get_magnitude()
                        self.x /= magnitude
                        self.y /= magnitude 

                    # rhs quer dizer Right Hand Side (Lado Direito)
                    def __add__(self, rhs):

                        return Vector2(self.x + rhs.x , self.y + rhs.y)


                A = (10.0, 20.0)
                B = (30.0, 35.0)
                C = (15.0, 45.0)

                AB = Vector2.from_points(A, B)
                BC = Vector2.from_points(B, C)
                
                AC = Vector2.from_points(A, C)
                print("Vector AC is", AC)

                AC = AB + BC
                print("AB + BC is", AC)

                # A execução desse script gera o resultado a seguir:
                Vector AC is (5.0, 25.0)
                AB + BC is (5.0, 25.0)




------------------------------------------------------------------------------
=============================
Subtração de Vetores
=============================
    Subtrair um vetor quer dizer ir na direção oposta á qual o vetor está apontando. Se o soldado Alpha for forçado a se proteger de um androide bem armado, ele poderá calcular um vetor até o seu adversário e entaão subtrair esse valor  de sua posição atual para localizar um ponto diretamente atrás dele. A matemática para a subtração de vetores é bem semelhante á da adição, porém subtraímos os componentes em vez de somá-los. O código dessa sessão mostra um método para subtrair um vetor de outro, que poderá ser acrescentado á classe Vector2. Observe que, de modo diferente dos métodos normais, esse método tem underscores duplos, como os métodos __init__ que vimos. Como criamos nosso próprio tipo de objeto, o Python não tem ideia dos tipos de propriedade que ele poderá ou não ter. Sendo assim, para que oPython possa tratar os símbolos como o sinal de subtração do modo como esperamos, devemos acrescentar métodos que tratarão essas ações. Se esses métodos não forem acrescentados, você obterá um erro em Python que informa o seguinte: TypeError: unsuported operand type(s) for -: 'Vector2' and ''Vector2''.

        exemplo de método para subtração:

            def __sub__(self, rhs): # rhs quer dizer Right Hand Side (Lado Direito).

                return Vector2(self.x - rhs, self.y - rhs)



---------------------------------------------------------------------------
=======================
Negação de valores
=======================
	Vamos supor que o soldado Alpha tenha chegado ao ponto B somente para descobrir que esqueceu suas baterias extras; como ele pode calcular um vetor de volta para A (ou seja, o vetor BA)? Ele poderia realizar o cálculo matemático, dados os pontos novamente, porém uma alternativa é negar o vetor AB, que já foi calculado. Negar um vetor cria um vetor de mesmo comprimento  que aponta para a direção oposta. Desse modo, -AB é o mesmo que BA. Para negar um vetor, basta negar seus componentes. O código dessa sessão apresenta uma função-membro que faz a negação; ela pode ser acrescentada á classe Vector2.

	    Exemplo de um método de negação de vetor:

	        def __neg__(self):

	            return Vector2(-self.x, -self.y)



---------------------------------------------------------------------------
===================================
Multiplicação e Divisão de Vetores
===================================
    Também é possível multiplicar (ou dividir) um vetor por um escalar (um número), o que tem o efeito de alterar o comprimento do vetor. Basta multiplicar ou dividir cada um dos componentes pelo valor escalar. O código abaixo acrescenta dois métodos á nossa classe Vector2 para implementar as funcionalidades de multiplicação e de divisão.

        ex:
        	def __mul__(self, scalar):
        	    return Vector2(self.x * scalar, self.y * scalar)

        	def __truediv__(self, scalar):
        	    return Vector2(self.x / scalar, self.y / scalar)


    Se você multiplicar qualquer vetor por 2,0, ele dobrará de tamanho; se um vetor for dividido por 2,0 (ou multiplicado por (0,5), ele terá metade do tamanho. AO MULTIPLICAR UM VETOR POR UM NÚMERO MAIOR QUE ZERO, O RESULTADO SERÁ UM VETOR QUE APONTA PARA A MESMA DIREÇÃO, porém, SE ELE FOR MULTIPLICADO POR UM NÚMERO MENOR QUE ZERO, O VETOR RESULTANTE SERÁ "invertido" E APONTARÁ PARA A DIREÇÃO OPOSTA. Veja na figura abaixo:

        ex: Multiplicando um vetor por um escalar


                                             /|
        	                                 /
        	                                /
        	               /|              /  
        	 vetor A       /              /    A * 2.0               O
        	(6.0, 5.0)    /              /   (12.0, 10.0)           /
        	             /              /                          /
        	            /              /                          /  A * -0.5
        	           O              /                          /   (3.0, 2.5)
                                     /                          /
        	           				/                          |/
        	                       O


            OBS: os valores 2.0 e -0.5 nesse exemplo são os valores escalar.

        	NOTA: Multiplicar um vetor por outro vetor também é possível, porém não é uma operação muito usada em jogos, e é provável que vc jamais precise dela.


    Então como o soldado Alpha poderá usar a multiplicação de vetores - ou, de modo mais exato, como o programador do jogo poderá usá-la? A multiplicação  de vetores é útil para dividir um vetor em passos menores de acordo com o tempo. Se soubermos que Alpha pode percorrer a distância de A e B em dez segundos, poderemos calcular as coordenadas em que Alpha estará após cada segundo ao usar um pouco de código de vetores. O código abaixo mostra como podemos fazer isso usando a classe Vector2.

        ex:
        	import pygame
        	import math

	        class Vector2():

			    def __init__(self, x=0, y=0):

			        self.x = x
			        self.y = y

			    def __str__(self):

			        return "(%s, %s)" %(self.x, self.y)

			    def from_points(P1, P2):

			        return Vector2 ( P2[0] - P1[0], P2[1] - P1[1] )

			    def get_magnitude(self):

			        return math.sqrt( self.x**2 + self.y**2 )

			    def normalize(self):

			        magnitude = self.get_magnitude()
			        self.x /= magnitude
			        self.y /= magnitude 

			    
			    def __add__(self, rhs): # rhs quer dizer Right Hand Side (Lado Direito)
			        
			        return Vector2(self.x + rhs.x , self.y + rhs.y)

			    def __mul__(self, scalar):

			        return Vector2(self.x * scalar, self.y * scalar)

			    def __truediv__(self, scalar):

			        return Vector2(self.x / scalar, self.y / scalar)



			A = (10.0, 20.0)
			B = (30.0, 35.0)
			AB = Vector2.from_points(A, B)
			step = AB * .1
			position = Vector2(*A)
			for n in range(10):
			    position += step
			    print(position)   


            Esse código gerará o seguinte resultado:

                (12.0, 21.5)
                (14.0, 23.0)	
                (16.0, 24.5)
                (18.0, 26.0)
                (20.0, 27.5)
                (22.0, 29.0)
                (24.0, 30.5)
                (26.0, 32.0)
                (28.0, 33.5)
                (30.0, 35.0)


    Após calcular um vetor entre os pontos A e B, o exemplo acima cria um vetor 'step' que tem um décimo do vetor AB. O código no loop soma esse valor a 'position', que é outro vetor usado para armazenar a posição atual de Alpha. Fazemos isso dez vezes, uma para cada segundo da jornada de Alpha, exibindo o vetor 'position' atual á medida que avançamos. Em algum momento, após as dez iterações, alcançaremos o ponto B sãos e salvos! Se vc usar o resultado e localizar os pontos em um gráfico, verá que eles formam uma linha reta perfeita de A até B.

    Calcular posições intermediárias dessa maneira é essencial quando nos movemos entre dois pontos. Também podemos usar vetores para criar diversos tipos de movimentos realistas.



------------------------------------------------------------------------------


